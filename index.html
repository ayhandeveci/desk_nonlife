<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<title>Exam Viewer - Soru Cevap + GPT</title>

<!-- MARKDOWN -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<!-- MATHJAX -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [["$", "$"], ["\\(", "\\)"]],
    displayMath: [["$$", "$$"], ["\\[", "\\]"]]
  },
  svg: { fontCache: "global" }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

<style>
  * { box-sizing: border-box; }

  body {
    margin: 0;
    font-family: Arial, sans-serif;
    height: 100vh;
    overflow: hidden;
  }

  /* ÜST BAR (Drive için) */
  #topBar {
    position: fixed;
    top: 0;
    left: 0;
    height: 45px;
    width: 100%;
    display: flex;
    gap: 10px;
    align-items: center;
    padding: 5px 10px;
    background: #ddd;
    border-bottom: 1px solid #aaa;
    z-index: 15;
  }

  button, input[type="file"] {
    padding: 6px;
    border-radius: 4px;
    border: 1px solid #555;
    background: #fff;
    font-size: 13px;
  }
  button:hover { background: #e7e7e7; }
  button:disabled { opacity: 0.5; cursor: not-allowed; }

  #status { font-size: 12px; margin-left: 10px; }

  /* GRID */
  #grid {
    position: absolute;
    top: 45px;
    left: 0;
    right: 0;
    bottom: 0;
    display: grid;
    grid-template-columns: 34% 66%;
    grid-template-rows: 50% 50%;
    grid-template-areas:
      "leftTop rightTop"
      "leftBottom rightBottom";
  }

  /* SOL ÜST (Listeler) */
  #leftTop {
    grid-area: leftTop;
    display: flex;
    flex-direction: row;
    background: #f3f3f3;
    border-right: 1px solid #ccc;
    border-bottom: 1px solid #ccc;
    min-height: 0;
  }

  .list-column {
    flex: 1;
    border-right: 1px solid #ccc;
    display: flex;
    flex-direction: column;
    min-width: 0;
  }
  .list-column:last-child {
    border-right: none;
  }

  .list-title {
    font-weight: bold;
    padding: 8px;
    background: #e9e9e9;
    border-bottom: 1px solid #ccc;
    text-align: center;
    font-size: 14px;
  }

  .file-list {
    flex: 1;
    overflow-y: auto;
    padding: 5px;
  }

  .file-item {
    padding: 6px;
    margin-bottom: 5px;
    cursor: pointer;
    background: #fff;
    border: 1px solid #bbb;
    border-radius: 4px;
    font-size: 13px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .file-item:hover { background: #e5e5e5; }

  /* SAĞ ÜST & SAĞ ALT */
  #rightTop {
    grid-area: rightTop;
    display: flex;
    flex-direction: column;
    border-bottom: 1px solid #ccc;
    min-height: 0;
  }

  #rightBottom {
    grid-area: rightBottom;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  .panel-title {
    padding: 6px 10px;
    background: #f0f0f0;
    border-bottom: 1px solid #ccc;
    font-weight: bold;
    font-size: 14px;
  }

  .img-area {
    flex: 1;
    position: relative;
    display: flex;
    flex-direction: column;
    background: #ffffff;
    overflow: auto; /* scroll */
    min-height: 0;
  }

  .img-holder {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 0;
  }

  .img-holder img {
    max-width: 95%;
    max-height: 95%;
    transition: transform 0.15s ease;
    transform-origin: center center;
  }

  /* ZOOM */
  .zoom-controls {
    position: absolute;
    top: 6px;
    right: 10px;
    z-index: 2;
    display: flex;
    gap: 5px;
  }
  .zoom-btn {
    width: 26px;
    height: 26px;
    background: #fff;
    border: 1px solid #888;
    border-radius: 4px;
    cursor: pointer;
    font-size: 18px;
    padding: 0;
    line-height: 22px;
  }
  .zoom-btn:hover { background: #f0f0f0; }

  /* SOL ALT (GPT Paneli) */
  #leftBottom {
    grid-area: leftBottom;
    display: flex;
    flex-direction: column;
    background: #fafafa;
    border-right: 1px solid #ccc;
    min-height: 0;
  }

  #gptHeader {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 5px 8px;
    border-bottom: 1px solid #ccc;
    font-size: 13px;
  }

  #gptHeader span.title {
    font-weight: bold;
    font-size: 14px;
    white-space: nowrap;
  }

  #gptControls {
    display: flex;
    align-items: center;
    gap: 6px;
    flex-wrap: wrap;
  }

  #gptStatus {
    font-size: 12px;
    color: #444;
  }

  #gptTabs {
    display: flex;
    border-bottom: 1px solid #ccc;
  }

  .gptTabBtn {
    flex: 1;
    padding: 8px;
    border: none;
    background: #e4e4e4;
    cursor: pointer;
    font-weight: bold;
  }

  .gptTabBtn.active {
    background: #ffffff;
    border-bottom: 2px solid #007bff;
  }

  #gptContent {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    min-height: 0;
  }

  .gptTabContent {
    font-size: 14px;
  }

  pre {
    background: #f5f5f5;
    padding: 6px;
    border-radius: 4px;
    overflow-x: auto;
  }
</style>
</head>

<body>

<!-- ÜST BAR: SA JSON + Liste Yükle -->
<div id="topBar">
  <input type="file" id="saFile" accept="application/json">
  <button id="loadBtn">PNG Listelerini Yükle</button>
  <span id="status"></span>
</div>

<!-- ANA GRID -->
<div id="grid">

  <!-- SOL ÜST: SORU/CEVAP Listeleri -->
  <div id="leftTop">
    <div class="list-column">
      <div class="list-title">SORULAR</div>
      <div id="soruList" class="file-list"></div>
    </div>
    <div class="list-column">
      <div class="list-title">CEVAPLAR</div>
      <div id="cevapList" class="file-list"></div>
    </div>
  </div>

  <!-- SAĞ ÜST: SORU PNG -->
  <div id="rightTop">
    <div class="panel-title" id="questionTitle">Soru</div>
    <div class="img-area" id="questionView">
      <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomIn('question')">+</button>
        <button class="zoom-btn" onclick="zoomOut('question')">-</button>
      </div>
      <div class="img-holder" id="questionImgHolder">
        <p>Seçilmedi</p>
      </div>
    </div>
  </div>

  <!-- SAĞ ALT: CEVAP PNG -->
  <div id="rightBottom">
    <div class="panel-title" id="answerTitle">Cevap</div>
    <div class="img-area" id="answerView">
      <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomIn('answer')">+</button>
        <button class="zoom-btn" onclick="zoomOut('answer')">-</button>
      </div>
      <div class="img-holder" id="answerImgHolder">
        <p>Seçilmedi</p>
      </div>
    </div>
  </div>

  <!-- SOL ALT: GPT PANELİ -->
  <div id="leftBottom">
    <div id="gptHeader">
      <span class="title">GPT Paneli</span>
      <div id="gptControls">
        <input type="file" id="gptFile" accept="application/json">
        <button id="runRawBtn" disabled>Ham Cevap Üret</button>
        <button id="runProcessBtn" disabled>Düzenlenmiş Cevap Üret</button>
        <span id="gptStatus"></span>
      </div>
    </div>
    <div id="gptTabs">
      <button class="gptTabBtn active" onclick="showGptTab('raw')">Ham Cevap</button>
      <button class="gptTabBtn" onclick="showGptTab('processed')">Düzenlenmiş Cevap</button>
    </div>
    <div id="gptContent">
      <div id="gptRaw" class="gptTabContent">Henüz cevap yok.</div>
      <div id="gptProcessed" class="gptTabContent" style="display:none;">Henüz düzenlenmiş cevap yok.</div>
    </div>
  </div>

</div>

<script>
/* === Sabitler === */
const FOLDER_SORULAR  = "1SM8NcS58qf-L9wOZ-ywZzg9gKhERZoK3";
const FOLDER_CEVAPLAR = "17IJCUY7xl52-YRyg7lP4FBJ-G3OohPx0";

/* === State === */
let saCredentials = null;
let openAIApiKey  = null;

let cacheSorular  = [];
let cacheCevaplar = [];

let currentQuestionFile = null;
let currentAnswerFile   = null;

let cachedToken    = null;
let cachedTokenExp = 0;

let zoomLevels = { question: 1, answer: 1 };

let rawAnswerText = "";  // GPT'den gelen ilk (ham) cevap

/* === Element referansları === */
const saFileInput   = document.getElementById("saFile");
const loadBtn       = document.getElementById("loadBtn");
const statusDiv     = document.getElementById("status");

const soruListDiv   = document.getElementById("soruList");
const cevapListDiv  = document.getElementById("cevapList");
const questionTitle = document.getElementById("questionTitle");
const answerTitle   = document.getElementById("answerTitle");
const questionImgHolder = document.getElementById("questionImgHolder");
const answerImgHolder   = document.getElementById("answerImgHolder");

const gptFileInput  = document.getElementById("gptFile");
const runRawBtn     = document.getElementById("runRawBtn");
const runProcessBtn = document.getElementById("runProcessBtn");
const gptStatus     = document.getElementById("gptStatus");
const gptRawDiv     = document.getElementById("gptRaw");
const gptProcessedDiv = document.getElementById("gptProcessed");

/* === SA JSON yükleme === */
saFileInput.onchange = (e) => {
  const f = e.target.files[0];
  if (!f) return;
  const r = new FileReader();
  r.onload = ev => {
    saCredentials = JSON.parse(ev.target.result);
    statusDiv.textContent = "Service Account JSON yüklendi.";
    updateGPTButtonsState();
  };
  r.readAsText(f);
};

/* === OpenAI JSON yükleme (GPT Paneli içinden) === */
gptFileInput.onchange = (e) => {
  const f = e.target.files[0];
  if (!f) return;
  const r = new FileReader();
  r.onload = ev => {
    const obj = JSON.parse(ev.target.result);
    openAIApiKey =
      obj.api_key ||
      obj.OPENAI_API_KEY ||
      obj.key ||
      null;
    if (openAIApiKey) {
      gptStatus.textContent = "OpenAI key hazır.";
    } else {
      gptStatus.textContent = "JSON içinde api_key bulunamadı.";
    }
    updateGPTButtonsState();
  };
  r.readAsText(f);
};

/* === PNG listelerini yükle === */
loadBtn.onclick = async () => {
  if (!saCredentials) {
    alert("Önce Service Account JSON yükle.");
    return;
  }
  statusDiv.textContent = "Sorular yükleniyor...";
  cacheSorular = sortPngList(await listPNGs(FOLDER_SORULAR));
  statusDiv.textContent = "Cevaplar yükleniyor...";
  cacheCevaplar = sortPngList(await listPNGs(FOLDER_CEVAPLAR));
  drawLists();
  statusDiv.textContent = "Listeler hazır.";
};

function sortPngList(list) {
  return (list || []).slice().sort((a, b) => {
    const aPrefix = parseInt(a.name.split('.')[0], 10);
    const bPrefix = parseInt(b.name.split('.')[0], 10);
    if (isNaN(aPrefix) || isNaN(bPrefix)) {
      return a.name.localeCompare(b.name, "tr");
    }
    return aPrefix - bPrefix;
  });
}

function drawLists() {
  soruListDiv.innerHTML = "";
  cevapListDiv.innerHTML = "";

  cacheSorular.forEach(item => {
    const d = document.createElement("div");
    d.className = "file-item";
    d.textContent = item.name;
    d.onclick = () => showQuestion(item);
    soruListDiv.appendChild(d);
  });

  cacheCevaplar.forEach(item => {
    const d = document.createElement("div");
    d.className = "file-item";
    d.textContent = item.name;
    d.onclick = () => showAnswer(item);
    cevapListDiv.appendChild(d);
  });
}

/* === Soru/Cevap göster === */
async function showQuestion(file) {
  currentQuestionFile = file;
  updateGPTButtonsState();

  questionTitle.textContent = "Soru: " + file.name;
  zoomLevels.question = 1;
  questionImgHolder.innerHTML = "<p>Yükleniyor...</p>";
  const img = await fetchPNGImage(file.id);
  questionImgHolder.innerHTML = "";
  questionImgHolder.appendChild(img);
  applyZoom("question");
}

async function showAnswer(file) {
  currentAnswerFile = file;
  updateGPTButtonsState();

  answerTitle.textContent = "Cevap: " + file.name;
  zoomLevels.answer = 1;
  answerImgHolder.innerHTML = "<p>Yükleniyor...</p>";
  const img = await fetchPNGImage(file.id);
  answerImgHolder.innerHTML = "";
  answerImgHolder.appendChild(img);
  applyZoom("answer");
}

/* === Drive'dan PNG çekme === */
async function fetchPNGBlob(id) {
  const token = await getToken();
  const url = `https://www.googleapis.com/drive/v3/files/${id}?alt=media`;
  const res = await fetch(url, {
    headers: { Authorization: "Bearer " + token }
  });
  return await res.blob();
}

async function fetchPNGImage(id) {
  const blob = await fetchPNGBlob(id);
  const img = document.createElement("img");
  img.src = URL.createObjectURL(blob);
  return img;
}

/* === Token yönetimi === */
async function getToken() {
  const now = Math.floor(Date.now() / 1000);
  if (cachedToken && cachedTokenExp - 60 > now) return cachedToken;

  const t = await createToken(saCredentials);
  cachedToken = t.access_token;
  cachedTokenExp = now + (t.expires_in || 3600);
  return cachedToken;
}

async function createToken(sa) {
  const now = Math.floor(Date.now() / 1000);
  const header = { alg: "RS256", typ: "JWT" };
  const payload = {
    iss: sa.client_email,
    scope: "https://www.googleapis.com/auth/drive.readonly",
    aud: "https://oauth2.googleapis.com/token",
    exp: now + 3600,
    iat: now,
  };

  const unsigned = b64(JSON.stringify(header)) + "." + b64(JSON.stringify(payload));

  const key = await crypto.subtle.importKey(
    "pkcs8",
    pemToBuf(sa.private_key),
    { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
    false,
    ["sign"]
  );

  const sig = await crypto.subtle.sign(
    "RSASSA-PKCS1-v1_5",
    key,
    new TextEncoder().encode(unsigned)
  );

  const jwt = unsigned + "." + b64Bytes(sig);

  const res = await fetch("https://oauth2.googleapis.com/token", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
      assertion: jwt,
    }),
  });

  return await res.json();
}

function b64(str) {
  return btoa(unescape(encodeURIComponent(str)))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/g, "");
}

function b64Bytes(ab) {
  let s = "", b = new Uint8Array(ab);
  for (let i = 0; i < b.length; i++) s += String.fromCharCode(b[i]);
  return btoa(s)
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/g, "");
}

function pemToBuf(pem) {
  const c = pem
    .replace(/-----BEGIN PRIVATE KEY-----/, "")
    .replace(/-----END PRIVATE KEY-----/, "")
    .replace(/\s+/g, "");
  const bin = atob(c);
  const buf = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) buf[i] = bin.charCodeAt(i);
  return buf.buffer;
}

/* === Zoom === */
function applyZoom(target) {
  const holder = target === "question" ? questionImgHolder : answerImgHolder;
  const img = holder.querySelector("img");
  if (!img) return;
  img.style.transform = `scale(${zoomLevels[target]})`;
}

function zoomIn(target) {
  zoomLevels[target] = Math.min(zoomLevels[target] + 0.2, 4);
  applyZoom(target);
}

function zoomOut(target) {
  zoomLevels[target] = Math.max(zoomLevels[target] - 0.2, 0.4);
  applyZoom(target);
}

/* === GPT sekmeleri === */
function showGptTab(which) {
  if (which === "raw") {
    gptRawDiv.style.display = "block";
    gptProcessedDiv.style.display = "none";
    document.querySelectorAll(".gptTabBtn")[0].classList.add("active");
    document.querySelectorAll(".gptTabBtn")[1].classList.remove("active");
  } else {
    gptRawDiv.style.display = "none";
    gptProcessedDiv.style.display = "block";
    document.querySelectorAll(".gptTabBtn")[0].classList.remove("active");
    document.querySelectorAll(".gptTabBtn")[1].classList.add("active");
  }
  if (window.MathJax && MathJax.typesetPromise) {
    MathJax.typesetPromise([document.getElementById("gptContent")]);
  }
}

/* === GPT butonlarının aktifliği === */
function updateGPTButtonsState() {
  const canRaw =
    !!openAIApiKey &&
    !!saCredentials &&
    !!currentQuestionFile &&
    !!currentAnswerFile;

  runRawBtn.disabled = !canRaw;

  const canProcess = !!openAIApiKey && !!rawAnswerText;
  runProcessBtn.disabled = !canProcess;
}

/* === Blob → Base64 === */
function blobToBase64(blob) {
  return new Promise((resolve) => {
    const r = new FileReader();
    r.onloadend = () => {
      resolve(r.result.split(",")[1]);
    };
    r.readAsDataURL(blob);
  });
}

/* === GPT: Ham Cevap Üret === */
runRawBtn.onclick = async () => {
  if (!openAIApiKey || !currentQuestionFile || !currentAnswerFile) {
    alert("Service account, OpenAI JSON, soru ve cevap seçilmiş olmalı.");
    return;
  }

  statusDiv.textContent = "GPT (Ham Cevap) çalışıyor...";
  gptStatus.textContent = "Görseller hazırlanıyor...";

  try {
    const [qBlob, aBlob] = await Promise.all([
      fetchPNGBlob(currentQuestionFile.id),
      fetchPNGBlob(currentAnswerFile.id)
    ]);

    const [qB64, aB64] = await Promise.all([
      blobToBase64(qBlob),
      blobToBase64(aBlob)
    ]);

    gptStatus.textContent = "GPT'ye gönderiliyor...";

    const firstAnswer = await callOpenAIForRaw(qB64, aB64, openAIApiKey);

    rawAnswerText = firstAnswer || "";
    gptRawDiv.innerHTML = marked.parse(rawAnswerText || "Boş cevap.");

    if (window.MathJax && MathJax.typesetPromise) {
      MathJax.typesetPromise([document.getElementById("gptContent")]);
    }

    showGptTab("raw");
    gptStatus.textContent = "Ham cevap hazır.";
    statusDiv.textContent = "GPT (Ham Cevap) tamamlandı.";

    updateGPTButtonsState();
  } catch (err) {
    console.error(err);
    gptStatus.textContent = "Ham GPT hata verdi.";
    statusDiv.textContent = "Hata: " + err;
  }
};

/* === GPT: Düzenlenmiş Cevap Üret === */
runProcessBtn.onclick = async () => {
  if (!openAIApiKey || !rawAnswerText) {
    alert("Önce ham cevabı üretmelisin.");
    return;
  }

  statusDiv.textContent = "GPT (Düzenleme) çalışıyor...";
  gptStatus.textContent = "Ham cevap GPT'ye tekrar gönderiliyor...";

  try {
    const finalAnswer = await callOpenAIForProcessed(rawAnswerText, openAIApiKey);

    gptProcessedDiv.innerHTML = marked.parse(finalAnswer || "Boş cevap.");

    if (window.MathJax && MathJax.typesetPromise) {
      MathJax.typesetPromise([document.getElementById("gptContent")]);
    }

    showGptTab("processed");
    gptStatus.textContent = "Düzenlenmiş cevap hazır.";
    statusDiv.textContent = "GPT (Düzenleme) tamamlandı.";
  } catch (err) {
    console.error(err);
    gptStatus.textContent = "Düzenleme GPT hata verdi.";
    statusDiv.textContent = "Hata: " + err;
  }
};

/* === OpenAI çağrıları === */

/* 1) Ham cevap için: görüntü + prompt */
async function callOpenAIForRaw(soruBase64, cevapBase64, apiKey) {
  const firstPrompt = `
Aşağıdaki iki görseli okuyacaksın:
1) Soru Görseli: problem metnini içerir.
2) Cevap Görseli: kullanıcının kendi çözüm notlarını içerir.

Görevlerin:
1) Önce soruyu Türkçe olarak kısa, net ve anlaşılır şekilde 3–5 cümlede özetle.
2) Ardından sorunun tam çözümünü adım adım matematiksel olarak doğru biçimde yaz.
3) Her adımın altına mutlaka kısa Türkçe açıklama ekle.
4) Hesaplamalarda LaTeX benzeri matematiksel gösterim kullan. Örneğin:

\`\`\`math
P(X = k) = \\lambda^k e^{-\\lambda} / k!
\`\`\`

5) Çözümün sonunda "Sonuç:" başlığı ile nihai cevabı açıkla.
6) Çıktının tamamını sadece Markdown formatında ver. HTML verme.
`;

  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": "Bearer " + apiKey,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "user",
          content: [
            { type: "text", text: firstPrompt },
            {
              type: "image_url",
              image_url: { url: "data:image/png;base64," + soruBase64 }
            },
            {
              type: "image_url",
              image_url: { url: "data:image/png;base64," + cevapBase64 }
            }
          ]
        }
      ]
    })
  });

  const json = await res.json();
  if (!json.choices || !json.choices[0]) {
    throw new Error("OpenAI ham cevap döndürmedi.");
  }
  return json.choices[0].message.content;
}

/* 2) Düzenlenmiş cevap için: sadece metin + ikinci prompt */
async function callOpenAIForProcessed(firstAnswerText, apiKey) {
  const secondPrompt = `
Aşağıda sana bir çözüm metni vereceğim. Bu metni ASLA anlam olarak değiştirme, sadece düzenle.

Görevlerin:
1) Metindeki tüm matematiksel formülleri tespit et.
2) Bu formülleri sırayla (A), (B), (C), ... şeklinde numaralandır.
3) "## Formülasyon Bölümü" başlığı altında, her satırda bir formül olacak şekilde yaz:

(A) ...formül...
(B) ...formül...

4) Sonra "## Metinsel Açıklama Bölümü" başlığı altında,
   her formül için ayrı bir açıklama paragrafı yaz. Her açıklama ilgili formüle (A), (B), ... şeklinde referans versin.
5) Formüllerin içeriğini ve metnin anlamını değiştirme.
6) Çıktının tamamını Markdown formatında ver.
`;

  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": "Bearer " + apiKey,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: secondPrompt },
        { role: "user", content: firstAnswerText }
      ]
    })
  });

  const json = await res.json();
  if (!json.choices || !json.choices[0]) {
    throw new Error("OpenAI düzenlenmiş cevap döndürmedi.");
  }
  return json.choices[0].message.content;
}

/* Drive listesi */
async function listPNGs(folderId) {
  const token = await getToken();
  const url =
    `https://www.googleapis.com/drive/v3/files?q='${folderId}' in parents and mimeType='image/png'&fields=files(id,name)&pageSize=500`;

  const res = await fetch(url, {
    headers: { Authorization: "Bearer " + token }
  });

  const j = await res.json();
  return j.files || [];
}
</script>
</body>
</html>
